<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D WebGL Character - Hitmonchan with Pauldrons</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #4a4a4a 0%, #2a2a2a 100%);
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
        }
        .controls h3 {
            margin: 0 0 10px 0;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
   

    </div>

    <script>
        // 1. Inisialisasi WebGL
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL not supported');
        }

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // 2. Definisi Shader (GLSL)
        const vsSource = `
            attribute vec3 aPosition;
            attribute vec3 aNormal;
            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat4 uNormalMatrix;
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            void main() {
                vec4 pos = uModelViewMatrix * vec4(aPosition, 1.0);
                vPosition = pos.xyz;
                vNormal = normalize((uNormalMatrix * vec4(aNormal, 0.0)).xyz);
                gl_Position = uProjectionMatrix * pos;
            }
        `;

        const fsSource = `
            precision mediump float;
            varying vec3 vNormal;
            varying vec3 vPosition;
            uniform vec3 uColor;
            uniform vec3 uLightPosition;
            uniform float uShininess;
            
            void main() {
                vec3 lightDir = normalize(uLightPosition - vPosition);
                vec3 normal = normalize(vNormal);
                
                float ambient = 0.4;
                float diffuse = max(dot(normal, lightDir), 0.0);
                
                vec3 viewDir = normalize(-vPosition);
                vec3 reflectDir = reflect(-lightDir, normal);
                float specular = pow(max(dot(viewDir, reflectDir), 0.0), uShininess) * 0.3;
                
                float lighting = ambient + diffuse * 0.6 + specular;
                vec3 finalColor = uColor * lighting;
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // 3. Kompilasi Program Shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
        }

        const locations = {
            aPosition: gl.getAttribLocation(program, 'aPosition'),
            aNormal: gl.getAttribLocation(program, 'aNormal'),
            uModelViewMatrix: gl.getUniformLocation(program, 'uModelViewMatrix'),
            uProjectionMatrix: gl.getUniformLocation(program, 'uProjectionMatrix'),
            uNormalMatrix: gl.getUniformLocation(program, 'uNormalMatrix'),
            uColor: gl.getUniformLocation(program, 'uColor'),
            uLightPosition: gl.getUniformLocation(program, 'uLightPosition'),
            uShininess: gl.getUniformLocation(program, 'uShininess')
        };

        // 4. Utilitas Matematika Matriks (mat4)
        function mat4Create() { return new Float32Array(16); }
        function mat4Identity(out) {
            out[0]=1; out[1]=0; out[2]=0; out[3]=0;
            out[4]=0; out[5]=1; out[6]=0; out[7]=0;
            out[8]=0; out[9]=0; out[10]=1; out[11]=0;
            out[12]=0; out[13]=0; out[14]=0; out[15]=1;
            return out;
        }
        function mat4Perspective(out, fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy / 2);
            out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0; out[11] = -1;
            out[12] = 0; out[13] = 0; out[15] = 0;
            if (far != null && far !== Infinity) {
                const nf = 1 / (near - far);
                out[10] = (far + near) * nf;
                out[14] = 2 * far * near * nf;
            } else {
                out[10] = -1;
                out[14] = -2 * near;
            }
            return out;
        }
        function mat4Translate(out, a, v) {
            const x = v[0], y = v[1], z = v[2];
            out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
            out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
            out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
            out[12] = a[0]*x + a[4]*y + a[8]*z + a[12];
            out[13] = a[1]*x + a[5]*y + a[9]*z + a[13];
            out[14] = a[2]*x + a[6]*y + a[10]*z + a[14];
            out[15] = a[3]*x + a[7]*y + a[11]*z + a[15];
            return out;
        }
        function mat4RotateX(out, a, rad) {
            const s = Math.sin(rad), c = Math.cos(rad);
            const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
            const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
            out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
            out[4] = a10*c + a20*s; out[5] = a11*c + a21*s;
            out[6] = a12*c + a22*s; out[7] = a13*c + a23*s;
            out[8] = a20*c - a10*s; out[9] = a21*c - a11*s;
            out[10] = a22*c - a12*s; out[11] = a23*c - a13*s;
            out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
            return out;
        }
        function mat4RotateY(out, a, rad) {
            const s = Math.sin(rad), c = Math.cos(rad);
            const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
            const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
            out[0] = a00*c - a20*s; out[1] = a01*c - a21*s;
            out[2] = a02*c - a22*s; out[3] = a03*c - a23*s;
            out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
            out[8] = a00*s + a20*c; out[9] = a01*s + a21*c;
            out[10] = a02*s + a22*c; out[11] = a03*s + a23*c;
            out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
            return out;
        }
        function mat4RotateZ(out, a, rad) {
            const s = Math.sin(rad), c = Math.cos(rad);
            const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
            const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
            out[0] = a00*c + a10*s; out[1] = a01*c + a11*s;
            out[2] = a02*c + a12*s; out[3] = a03*c + a13*s;
            out[4] = a10*c - a00*s; out[5] = a11*c - a01*s;
            out[6] = a12*c - a02*s; out[7] = a13*c - a03*s;
            out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
            out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
            return out;
        }
        function mat4Scale(out, a, v) {
            const x = v[0], y = v[1], z = v[2];
            out[0] = a[0] * x; out[1] = a[1] * x; out[2] = a[2] * x; out[3] = a[3] * x;
            out[4] = a[4] * y; out[5] = a[5] * y; out[6] = a[6] * y; out[7] = a[7] * y;
            out[8] = a[8] * z; out[9] = a[9] * z; out[10] = a[10] * z; out[11] = a[11] * z;
            out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
            return out;
        }
        function mat4Multiply(out, a, b) {
            const a00=a[0],a01=a[1],a02=a[2],a03=a[3],a10=a[4],a11=a[5],a12=a[6],a13=a[7],a20=a[8],a21=a[9],a22=a[10],a23=a[11],a30=a[12],a31=a[13],a32=a[14],a33=a[15];
            let b0=b[0],b1=b[1],b2=b[2],b3=b[3];
            out[0]=b0*a00+b1*a10+b2*a20+b3*a30; out[1]=b0*a01+b1*a11+b2*a21+b3*a31; out[2]=b0*a02+b1*a12+b2*a22+b3*a32; out[3]=b0*a03+b1*a13+b2*a23+b3*a33;
            b0=b[4]; b1=b[5]; b2=b[6]; b3=b[7];
            out[4]=b0*a00+b1*a10+b2*a20+b3*a30; out[5]=b0*a01+b1*a11+b2*a21+b3*a31; out[6]=b0*a02+b1*a12+b2*a22+b3*a32; out[7]=b0*a03+b1*a13+b2*a23+b3*a33;
            b0=b[8]; b1=b[9]; b2=b[10]; b3=b[11];
            out[8]=b0*a00+b1*a10+b2*a20+b3*a30; out[9]=b0*a01+b1*a11+b2*a21+b3*a31; out[10]=b0*a02+b1*a12+b2*a22+b3*a32; out[11]=b0*a03+b1*a13+b2*a23+b3*a33;
            b0=b[12]; b1=b[13]; b2=b[14]; b3=b[15];
            out[12]=b0*a00+b1*a10+b2*a20+b3*a30; out[13]=b0*a01+b1*a11+b2*a21+b3*a31; out[14]=b0*a02+b1*a12+b2*a22+b3*a32; out[15]=b0*a03+b1*a13+b2*a23+b3*a33;
            return out;
        }
        function mat4Invert(out, a) {
            const a00=a[0],a01=a[1],a02=a[2],a03=a[3],a10=a[4],a11=a[5],a12=a[6],a13=a[7],a20=a[8],a21=a[9],a22=a[10],a23=a[11],a30=a[12],a31=a[13],a32=a[14],a33=a[15];
            const b00=a00*a11-a01*a10, b01=a00*a12-a02*a10, b02=a00*a13-a03*a10, b03=a01*a12-a02*a11, b04=a01*a13-a03*a11, b05=a02*a13-a03*a12;
            const b06=a20*a31-a21*a30, b07=a20*a32-a22*a30, b08=a20*a33-a23*a30, b09=a21*a32-a22*a31, b10=a21*a33-a23*a31, b11=a22*a33-a23*a32;
            let det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;
            if(!det)return null;
            det=1.0/det;
            out[0]=(a11*b11-a12*b10+a13*b09)*det; out[1]=(a02*b10-a01*b11-a03*b09)*det; out[2]=(a31*b05-a32*b04+a33*b03)*det; out[3]=(a22*b04-a21*b05-a23*b03)*det;
            out[4]=(a12*b08-a10*b11-a13*b07)*det; out[5]=(a00*b11-a02*b08+a03*b07)*det; out[6]=(a32*b02-a30*b05-a33*b01)*det; out[7]=(a20*b05-a22*b02+a23*b01)*det;
            out[8]=(a10*b10-a11*b08+a13*b06)*det; out[9]=(a01*b08-a00*b10-a03*b06)*det; out[10]=(a30*b04-a31*b02+a33*b00)*det; out[11]=(a21*b02-a20*b04-a23*b00)*det;
            out[12]=(a11*b07-a10*b09-a12*b06)*det; out[13]=(a00*b09-a01*b07+a02*b06)*det; out[14]=(a31*b01-a30*b03-a32*b00)*det; out[15]=(a20*b03-a21*b01+a22*b00)*det;
            return out;
        }
        function mat4Transpose(out, a) {
            if(out===a){const a01=a[1],a02=a[2],a03=a[3],a12=a[6],a13=a[7],a23=a[11]; out[1]=a[4];out[2]=a[8];out[3]=a[12]; out[4]=a01;out[6]=a[9];out[7]=a[13]; out[8]=a02;out[9]=a12;out[11]=a[14]; out[12]=a03;out[13]=a13;out[14]=a23;}
            else{out[0]=a[0];out[1]=a[4];out[2]=a[8];out[3]=a[12]; out[4]=a[1];out[5]=a[5];out[6]=a[9];out[7]=a[13]; out[8]=a[2];out[9]=a[6];out[10]=a[10];out[11]=a[14]; out[12]=a[3];out[13]=a[7];out[14]=a[11];out[15]=a[15];}
            return out;
        }
        function mat4Rotate(out, a, rad, axis) {
            let x = axis[0], y = axis[1], z = axis[2];
            let len = Math.hypot(x, y, z);
            if (len < 0.000001) { return null; }
            len = 1 / len;
            x *= len; y *= len; z *= len;
            
            const s = Math.sin(rad), c = Math.cos(rad), t = 1 - c;
            
            const b = mat4Create();
            b[0] = x * x * t + c;     b[1] = y * x * t + z * s;     b[2] = z * x * t - y * s;     b[3] = 0;
            b[4] = x * y * t - z * s; b[5] = y * y * t + c;         b[6] = z * y * t + x * s;     b[7] = 0;
            b[8] = x * z * t + y * s; b[9] = y * z * t - x * s;     b[10] = z * z * t + c;        b[11] = 0;
            b[12] = 0;                b[13] = 0;                  b[14] = 0;                  b[15] = 1;

            return mat4Multiply(out, a, b);
        }

        // 5. Definisi Geometri Model
        function createHead() {
            const v = []; const n = []; const i = [];
            const w=0.32,h=0.35,d=0.28,fz=0.3,bz=-d; const bw=w*0.85,bh=h*0.9;
            v.push(-w,h,fz, w,h,fz, -w,0,fz, w,0,fz, -w,-h,fz, w,-h,fz);
            for(let j=0;j<6;j++)n.push(0,0,1); i.push(0,2,3, 0,3,1, 2,4,5, 2,5,3);
            v.push(-bw,bh,bz, bw,bh,bz, -bw,0,bz, bw,0,bz, -bw,-bh,bz, bw,-bh,bz);
            for(let j=0;j<6;j++)n.push(0,0,-1); i.push(6,9,8, 6,7,9, 8,11,10, 8,9,11);
            v.push(-w,h,fz, w,h,fz, bw,bh,bz, -bw,bh,bz);
            for(let j=0;j<4;j++)n.push(0,1,0); i.push(12,13,14, 12,14,15);
            v.push(-w,-h,fz, w,-h,fz, bw,-bh,bz, -bw,-bh,bz);
            for(let j=0;j<4;j++)n.push(0,-1,0); i.push(16,19,18, 16,18,17);
            v.push(-w,h,fz, -w,-h,fz, -bw,-bh,bz, -bw,bh,bz);
            for(let j=0;j<4;j++)n.push(-1,0,0); i.push(20,21,22, 20,22,23);
            v.push(w,h,fz, w,-h,fz, bw,-bh,bz, bw,bh,bz);
            for(let j=0;j<4;j++)n.push(1,0,0); i.push(24,27,26, 24,26,25);
            return {vertices: new Float32Array(v), normals: new Float32Array(n), indices: new Uint16Array(i)};
        }

        function createHair() {
            const v = [], n = [], i = [];
            const spikes = [
                {base:[[-0.08,0.35,0.1],[0.08,0.35,0.1],[0.08,0.35,-0.05],[-0.08,0.35,-0.05]],tip:[0,0.95,0.05]},
                {base:[[-0.32,0.3,0.08],[-0.18,0.32,0.12],[-0.2,0.3,-0.05],[-0.3,0.28,-0.02]],tip:[-0.38,0.75,0.05]},
                {base:[[0.18,0.32,0.12],[0.32,0.3,0.08],[0.3,0.28,-0.02],[0.2,0.3,-0.05]],tip:[0.38,0.75,0.05]},
                {base:[[-0.2,0.35,0.1],[-0.1,0.36,0.08],[-0.12,0.34,-0.02],[-0.18,0.33,0]],tip:[-0.15,0.85,0.05]},
                {base:[[0.1,0.36,0.08],[0.2,0.35,0.1],[0.18,0.33,0],[0.12,0.34,-0.02]],tip:[0.15,0.85,0.05]}
            ];
            let vi = 0;
            spikes.forEach(s => {
                const bs = vi;
                s.base.forEach(b => {
                    v.push(...b);
                    const nx=b[0]*0.3,ny=0.7,nz=b[2]*0.3,ln=Math.sqrt(nx*nx+ny*ny+nz*nz);
                    n.push(nx/ln, ny/ln, nz/ln);
                });
                v.push(...s.tip); n.push(0, 1, 0);
                const ti = vi + s.base.length;
                for (let j = 0; j < s.base.length; j++) {
                    const nx = (j + 1) % s.base.length;
                    i.push(bs + j, ti, bs + nx);
                }
                i.push(bs, bs+2, bs+1, bs, bs+3, bs+2);
                vi = v.length / 3;
            });
            return {vertices: new Float32Array(v), normals: new Float32Array(n), indices: new Uint16Array(i)};
        }

        function createEyes() {
            const v = [], n = [], i = [];
            const ed = [{cx: -0.15, cy: 0.05}, {cx: 0.15, cy: 0.05}];
            let vi = 0;
            ed.forEach(e => {
                const w=0.1,h=0.14,z=0.31;
                v.push(e.cx-w*0.7,e.cy+h,z, e.cx+w*0.7,e.cy+h,z, e.cx+w,e.cy,z, e.cx-w,e.cy,z, e.cx+w*0.6,e.cy-h*0.9,z, e.cx-w*0.6,e.cy-h*0.9,z);
                for(let j=0;j<6;j++)n.push(0,0,1);
                i.push(vi,vi+1,vi+2, vi,vi+2,vi+3, vi+3,vi+2,vi+4, vi+3,vi+4,vi+5);
                vi += 6;
            });
            return {vertices: new Float32Array(v), normals: new Float32Array(n), indices: new Uint16Array(i)};
        }

        function createPupils() {
            const v = [], n = [], i = [];
            const pd = [{cx: -0.15, cy: 0.02}, {cx: 0.15, cy: 0.02}];
            let vi = 0;
            pd.forEach(p => {
                const w=0.045,h=0.08,z=0.32;
                v.push(p.cx,p.cy+h,z, p.cx+w,p.cy,z, p.cx,p.cy-h,z, p.cx-w,p.cy,z);
                for(let j=0;j<4;j++)n.push(0,0,1);
                i.push(vi, vi+1, vi+2, vi, vi+2, vi+3);
                vi += 4;
            });
            return {vertices: new Float32Array(v), normals: new Float32Array(n), indices: new Uint16Array(i)};
        }

        function createMouth() {
            const v = [], n = [], i = [];
            const z=0.305,cy=-0.15,w=0.2,h=0.08,sg=10;
            let vi = 0;
            for(let j=0;j<=sg;j++){
                const t=j/sg,x=(t-0.5)*w*2,y=cy-Math.sin(t*Math.PI)*h;
                v.push(x,y,z, x,y-0.02,z);
                n.push(0,0,1, 0,0,1);
                if(j<sg){ i.push(vi,vi+1,vi+3, vi,vi+3,vi+2); vi+=2; } else vi+=2;
            }
            return {vertices: new Float32Array(v), normals: new Float32Array(n), indices: new Uint16Array(i)};
        }

        function createTorso() {
            const vertices = []; const normals = []; const indices = [];
            const topRadius = 0.4, topY = 0.5;
            const midRadius = 0.35, midY = 0.0;
            const bottomRadius = 0.6, bottomY = -0.8;
            const segments = 20;
            
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                const cosT = Math.cos(theta), sinT = Math.sin(theta);
                vertices.push(topRadius * cosT, topY, topRadius * sinT); normals.push(cosT, 0.3, sinT);
                vertices.push(midRadius * cosT, midY, midRadius * sinT); normals.push(cosT, 0, sinT);
                vertices.push(bottomRadius * cosT, bottomY, bottomRadius * sinT); normals.push(cosT, -0.2, sinT);
            }
            for (let i = 0; i < segments; i++) {
                const i0 = i * 3, i1 = (i + 1) * 3;
                indices.push(i0, i1, i0 + 1); indices.push(i1, i1 + 1, i0 + 1);
                indices.push(i0 + 1, i1 + 1, i0 + 2); indices.push(i1 + 1, i1 + 2, i0 + 2);
            }
            const topCenter = vertices.length / 3;
            vertices.push(0, topY, 0); normals.push(0, 1, 0);
            for (let i = 0; i < segments; i++) { indices.push(topCenter, (i + 1) * 3, i * 3); }
            const bottomCenter = vertices.length / 3;
            vertices.push(0, bottomY, 0); normals.push(0, -1, 0);
            for (let i = 0; i < segments; i++) { indices.push(bottomCenter, i * 3 + 2, (i + 1) * 3 + 2); }
            
            return { vertices: new Float32Array(vertices), normals: new Float32Array(normals), indices: new Uint16Array(indices) };
        }

        function createLimb(topRadius, bottomRadius, height, segments) { 
            const vertices = []; const normals = []; const indices = [];
            const topY = height / 2, bottomY = -height / 2;
            
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                const cosT = Math.cos(theta), sinT = Math.sin(theta);
                vertices.push(topRadius * cosT, topY, topRadius * sinT); normals.push(cosT, 0.1, sinT);
                vertices.push(bottomRadius * cosT, bottomY, bottomRadius * sinT); normals.push(cosT, -0.1, sinT);
            }
            for (let i = 0; i < segments; i++) {
                const i0 = i * 2, i1 = (i + 1) * 2;
                indices.push(i0, i1, i0 + 1); indices.push(i1, i1 + 1, i0 + 1);
            }
            const topCenter = vertices.length / 3;
            vertices.push(0, topY, 0); normals.push(0, 1, 0);
            for (let i = 0; i < segments; i++) { indices.push(topCenter, (i + 1) * 2, i * 2); }
            const bottomCenter = vertices.length / 3;
            vertices.push(0, bottomY, 0); normals.push(0, -1, 0);
            for (let i = 0; i < segments; i++) { indices.push(bottomCenter, i * 2 + 1, (i + 1) * 2 + 1); }
            
            return { vertices: new Float32Array(vertices), normals: new Float32Array(normals), indices: new Uint16Array(indices) };
        }

        function createSphere(radius, segments) {
            const vertices = []; const normals = []; const indices = [];
            for (let i = 0; i <= segments; i++) {
                const latAngle = Math.PI * (-0.5 + (i / segments));
                const sinLat = Math.sin(latAngle), cosLat = Math.cos(latAngle);
                for (let j = 0; j <= segments; j++) {
                    const lonAngle = 2 * Math.PI * (j / segments);
                    const sinLon = Math.sin(lonAngle), cosLon = Math.cos(lonAngle);
                    const x = cosLat * cosLon, y = sinLat, z = cosLat * sinLon;
                    vertices.push(x * radius, y * radius, z * radius);
                    normals.push(x, y, z);
                }
            }
            for (let i = 0; i < segments; i++) {
                for (let j = 0; j < segments; j++) {
                    const first = (i * (segments + 1)) + j;
                    const second = first + segments + 1;
                    indices.push(first, second, first + 1);
                    indices.push(second, second + 1, first + 1);
                }
            }
            return { vertices: new Float32Array(vertices), normals: new Float32Array(normals), indices: new Uint16Array(indices) };
        }

        function createFoot() {
            const v = [
                -0.15,-0.1,0.2,  0.15,-0.1,0.2, -0.15,0.1,0.0,  0.15,0.1,0.0,
                -0.15,-0.1,-0.1,  0.15,-0.1,-0.1, -0.15,0.1,-0.1,  0.15,0.1,-0.1,
                -0.15,0.1,0.0,  0.15,0.1,0.0, -0.15,0.1,-0.1,  0.15,0.1,-0.1,
                -0.15,-0.1,0.2,  0.15,-0.1,0.2, -0.15,-0.1,-0.1,  0.15,-0.1,-0.1,
                -0.15,-0.1,0.2, -0.15,0.1,0.0, -0.15,-0.1,-0.1, -0.15,0.1,-0.1,
                 0.15,-0.1,0.2,  0.15,0.1,0.0,  0.15,-0.1,-0.1,  0.15,0.1,-0.1
            ];
            const n = [
                0,0,1,0,0,1,0,0,1,0,0,1, 0,0,-1,0,0,-1,0,0,-1,0,0,-1,
                0,1,0,0,1,0,0,1,0,0,1,0, 0,-1,0,0,-1,0,0,-1,0,0,-1,0,
                -1,0,0,-1,0,0,-1,0,0,-1,0,0, 1,0,0,1,0,0,1,0,0,1,0,0
            ];
            const i = [
                0,1,2, 1,3,2, 4,6,5, 5,6,7, 8,9,10, 9,11,10,
                12,14,13, 13,14,15, 16,18,17, 17,18,19, 20,21,22, 21,23,22
            ];
            return { vertices: new Float32Array(v), normals: new Float32Array(n), indices: new Uint16Array(i) };
        }

        function createPauldronGeometry() {
            const positions = [];
            const normals = [];
            const indices = [];
            
            const segments = 16;
            const layers = 3;
            const radiusTop = 0.2;
            const radiusBottom = 0.3;
            const height = 0.3;
            const thickness = 0.04;
            const angleStart = -Math.PI * 0.6;
            const angleEnd = Math.PI * 0.1;
            
            for (let layer = 0; layer <= layers; layer++) {
                const t = layer / layers;
                const y = -height * t;
                const radius = radiusTop + (radiusBottom - radiusTop) * t;
                
                for (let seg = 0; seg <= segments; seg++) {
                    const angle = angleStart + (angleEnd - angleStart) * (seg / segments);
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    
                    positions.push(x, y, z);
                    
                    const nx = Math.cos(angle);
                    const ny = 0.2;
                    const nz = Math.sin(angle);
                    const len = Math.sqrt(nx * nx + ny * ny + nz * nz);
                    normals.push(nx / len, ny / len, nz / len);
                    
                    if (layer < layers && seg < segments) {
                        const curr = layer * (segments + 1) + seg;
                        const next = curr + segments + 1;
                        
                        indices.push(curr, next, curr + 1);
                        indices.push(curr + 1, next, next + 1);
                    }
                }
            }
            
            const outerVertCount = positions.length / 3;
            
            for (let layer = 0; layer <= layers; layer++) {
                const t = layer / layers;
                const y = -height * t;
                const radius = radiusTop + (radiusBottom - radiusTop) * t - thickness;
                
                for (let seg = 0; seg <= segments; seg++) {
                    const angle = angleStart + (angleEnd - angleStart) * (seg / segments);
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    
                    positions.push(x, y, z);
                    
                    const nx = -Math.cos(angle);
                    const ny = -0.2;
                    const nz = -Math.sin(angle);
                    const len = Math.sqrt(nx * nx + ny * ny + nz * nz);
                    normals.push(nx / len, ny / len, nz / len);
                    
                    if (layer < layers && seg < segments) {
                        const curr = outerVertCount + layer * (segments + 1) + seg;
                        const next = curr + segments + 1;
                        
                        indices.push(curr, curr + 1, next);
                        indices.push(curr + 1, next + 1, next);
                    }
                }
            }
            
            const baseOuter = 0;
            const baseInner = outerVertCount;
            
            for (let seg = 0; seg < segments; seg++) {
                const o1 = baseOuter + seg;
                const o2 = baseOuter + seg + 1;
                const i1 = baseInner + seg;
                const i2 = baseInner + seg + 1;
                
                indices.push(o1, i1, o2);
                indices.push(o2, i1, i2);
            }
            
            for (let seg = 0; seg < segments; seg++) {
                const o1 = baseOuter + layers * (segments + 1) + seg;
                const o2 = baseOuter + layers * (segments + 1) + seg + 1;
                const i1 = baseInner + layers * (segments + 1) + seg;
                const i2 = baseInner + layers * (segments + 1) + seg + 1;
                
                indices.push(o1, o2, i1);
                indices.push(o2, i2, i1);
            }
            
            for (let layer = 0; layer < layers; layer++) {
                const o1 = baseOuter + layer * (segments + 1);
                const o2 = baseOuter + (layer + 1) * (segments + 1);
                const i1 = baseInner + layer * (segments + 1);
                const i2 = baseInner + (layer + 1) * (segments + 1);
                
                indices.push(o1, i1, o2);
                indices.push(o2, i1, i2);
                
                const o3 = baseOuter + layer * (segments + 1) + segments;
                const o4 = baseOuter + (layer + 1) * (segments + 1) + segments;
                const i3 = baseInner + layer * (segments + 1) + segments;
                const i4 = baseInner + (layer + 1) * (segments + 1) + segments;
                
                indices.push(o3, o4, i3);
                indices.push(o4, i4, i3);
            }
            
            return { vertices: new Float32Array(positions), normals: new Float32Array(normals), indices: new Uint16Array(indices) };
        }

        // 6. Setup Buffer WebGL
        const head = createHead();
        const hair = createHair();
        const eyes = createEyes();
        const pupils = createPupils();
        const mouth = createMouth();
        const torso = createTorso();
        const arm = createLimb(0.11, 0.09, 0.7, 12); 
        const leg = createLimb(0.18, 0.15, 0.8, 12);
        const glove = createSphere(0.25, 16);
        const shoulder = createSphere(0.2, 16);
        const foot = createFoot();
        const belt = createLimb(0.35, 0.38, 0.1, 20);
        const pauldron = createPauldronGeometry();

        function createBuffer(data) {
            const pb = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, pb);
            gl.bufferData(gl.ARRAY_BUFFER, data.vertices, gl.STATIC_DRAW);
            const nb = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, nb);
            gl.bufferData(gl.ARRAY_BUFFER, data.normals, gl.STATIC_DRAW);
            const ib = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data.indices, gl.STATIC_DRAW);
            return {pos: pb, norm: nb, idx: ib};
        }

        const headB = createBuffer(head);
        const hairB = createBuffer(hair);
        const eyeB = createBuffer(eyes);
        const pupilB = createBuffer(pupils);
        const mouthB = createBuffer(mouth);
        const torsoB = createBuffer(torso);
        const armB = createBuffer(arm);
        const legB = createBuffer(leg);
        const gloveB = createBuffer(glove);
        const shoulderB = createBuffer(shoulder);
        const footB = createBuffer(foot);
        const beltB = createBuffer(belt);
        const pauldronB = createBuffer(pauldron);

        // 7. Kontrol Input & Interaksi
        let rx = 0.2, ry = 0, zoom = -5, drag = false, lx, ly;
        canvas.addEventListener('mousedown', (e) => { drag = true; lx = e.clientX; ly = e.clientY; });
        canvas.addEventListener('mousemove', (e) => {
            if (drag) { ry += (e.clientX - lx) * 0.01; rx += (e.clientY - ly) * 0.01; lx = e.clientX; ly = e.clientY; }
        });
        canvas.addEventListener('mouseup', () => drag = false);
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault(); zoom += e.deltaY * 0.01; zoom = Math.max(-15, Math.min(-2, zoom));
        });

        // 8. Logika Render & Animasi
        function drawMesh(buf, cnt, col, shi) {
            gl.uniform3fv(locations.uColor, col);
            gl.uniform1f(locations.uShininess, shi);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, buf.pos);
            gl.vertexAttribPointer(locations.aPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(locations.aPosition);

            gl.bindBuffer(gl.ARRAY_BUFFER, buf.norm);
            gl.vertexAttribPointer(locations.aNormal, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(locations.aNormal);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf.idx);
            gl.drawElements(gl.TRIANGLES, cnt, gl.UNSIGNED_SHORT, 0);
        }

        function setMatricesAndDraw(mvMatrix, buf, cnt, col, shi) {
            const nm = mat4Create();
            mat4Invert(nm, mvMatrix);
            mat4Transpose(nm, nm);
            
            gl.uniformMatrix4fv(locations.uModelViewMatrix, false, mvMatrix);
            gl.uniformMatrix4fv(locations.uNormalMatrix, false, nm);
            
            drawMesh(buf, cnt, col, shi);
        }

        const bodyColor = [0.65, 0.55, 0.48];
        const gloveColor = [0.8, 0.1, 0.1];
        const tunicColor = [0.95, 0.7, 0.75];
        const hairColor = [0.3, 0.2, 0.15];
        const beltColor = [0.1, 0.1, 0.1];
        const pauldronColor = [0.87, 0.72, 0.53];

        let currentWalkAngle = 0;
        let currentWalkBob = 0;
        let currentPunchOffset = 0;
        let currentBodyTilt = 0;
        let currentHeadTurn = 0;
        let lastTime = 0;
        const tiltAxis = [0.7071, 0, 0.7071];

        function render(now) {
            now *= 0.001;
            const deltaTime = now - (lastTime || now);
            lastTime = now;
            
            const smoothFactor = 1.0 - Math.pow(0.01, deltaTime);

            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.0, 0.0, 0.0, 0.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.useProgram(program);

            const breathScale = 1.0 + Math.sin(now * Math.PI) * 0.05;

            const cycleDuration = 8.0; 
            const walkDuration = 5.0;  
            
            const totalTimeSeconds = now;
            const timeInCycle = totalTimeSeconds % cycleDuration; 

            const isWalking = timeInCycle < walkDuration;
            const isPunching = !isWalking;

            let targetWalkAngle = 0;
            let targetWalkBob = 0;
            let targetPunchOffset = 0; 
            let targetBodyTilt = 0; 
            let targetHeadTurn = 0; 

            if (isWalking) {
                const walkTime = totalTimeSeconds * 5.0; 
                targetWalkAngle = Math.sin(walkTime) * 0.4;
                targetWalkBob = (1.0 - Math.cos(walkTime * 2.0)) * 0.025; 
                
                targetPunchOffset = 0;
                targetBodyTilt = 0;
                targetHeadTurn = 0;
            } else {
                targetWalkAngle = 0;
                targetWalkBob = 0;

                const punchPhaseTime = (timeInCycle - walkDuration) * 10.0; 
                targetPunchOffset = Math.abs(Math.sin(punchPhaseTime)) * 1.0; 
                
                const posePhaseTime = (timeInCycle - walkDuration) * 2.0; 
                targetBodyTilt = Math.sin(posePhaseTime) * 0.25; 
                targetHeadTurn = Math.sin(posePhaseTime) * -0.5; 
            }

            currentWalkAngle   += (targetWalkAngle - currentWalkAngle) * smoothFactor;
            currentWalkBob     += (targetWalkBob - currentWalkBob) * smoothFactor;
            currentPunchOffset += (targetPunchOffset - currentPunchOffset) * smoothFactor;
            currentBodyTilt    += (targetBodyTilt - currentBodyTilt) * smoothFactor;
            currentHeadTurn    += (targetHeadTurn - currentHeadTurn) * smoothFactor;

            const blinkCycleTime = totalTimeSeconds % 4.0; 
            let eyeScaleY = 1.0; 
            if (blinkCycleTime < 0.15) {
                const blinkProgress = blinkCycleTime / 0.15; 
                eyeScaleY = 1.0 - Math.sin(blinkProgress * Math.PI);
                eyeScaleY = Math.max(0.1, eyeScaleY); 
            }
            
            const pm = mat4Create();
            mat4Perspective(pm, Math.PI / 4, canvas.width / canvas.height, 0.1, 100);
            gl.uniformMatrix4fv(locations.uProjectionMatrix, false, pm);
            gl.uniform3fv(locations.uLightPosition, [2, 3, 4]);

            const baseMv = mat4Create();
            mat4Identity(baseMv);
            mat4Translate(baseMv, baseMv, [0, -0.5 + currentWalkBob, zoom]); 
            mat4RotateX(baseMv, baseMv, rx);
            mat4RotateY(baseMv, baseMv, ry);
            mat4Rotate(baseMv, baseMv, currentBodyTilt, tiltAxis);
            
            const partMv = mat4Create();
            const gloveMv = mat4Create();

            mat4Identity(partMv);
            mat4Scale(partMv, partMv, [breathScale, 1.0, breathScale]); 
            mat4Multiply(partMv, baseMv, partMv); 
            setMatricesAndDraw(partMv, torsoB, torso.indices.length, tunicColor, 8.0);

            const beltMv = mat4Create();
            mat4Identity(beltMv);
            mat4Translate(beltMv, beltMv, [0, -0.05, 0]);
            mat4Scale(beltMv, beltMv, [breathScale * 1.05, 1.0, breathScale * 1.05]);
            mat4Multiply(beltMv, baseMv, beltMv);
            setMatricesAndDraw(beltMv, beltB, belt.indices.length, beltColor, 16.0);

            mat4Identity(partMv);
            mat4Translate(partMv, partMv, [0, 0.9, 0]); 
            mat4RotateY(partMv, partMv, currentHeadTurn);
            mat4Multiply(partMv, baseMv, partMv); 
            
            setMatricesAndDraw(partMv, headB, head.indices.length, bodyColor, 8.0);
            setMatricesAndDraw(partMv, hairB, hair.indices.length, bodyColor, 8.0); 
            
            const eyeMv = mat4Create();
            mat4Identity(eyeMv);
            mat4Translate(eyeMv, eyeMv, [0, 0.05, 0]); 
            mat4Scale(eyeMv, eyeMv, [1.0, eyeScaleY, 1.0]);
            mat4Translate(eyeMv, eyeMv, [0, -0.05, 0]);
            mat4Multiply(eyeMv, partMv, eyeMv); 

            setMatricesAndDraw(eyeMv, eyeB, eyes.indices.length, [1,1,1], 32.0);
            setMatricesAndDraw(eyeMv, pupilB, pupils.indices.length, [0.1,0.1,0.1], 64.0);

            setMatricesAndDraw(partMv, mouthB, mouth.indices.length, [0.4, 0.35, 0.33], 8.0);

            mat4Identity(partMv);
            mat4Translate(partMv, partMv, [-0.4, 0.52, 0]);
            mat4Scale(partMv, partMv, [1.0, 0.8, 1.0]); 
            mat4Multiply(partMv, baseMv, partMv);
            setMatricesAndDraw(partMv, shoulderB, shoulder.indices.length, bodyColor, 8.0);

            const pauldronLeftMv = mat4Create();
            mat4Identity(pauldronLeftMv);
            mat4Translate(pauldronLeftMv, pauldronLeftMv, [-0.8, 0.62, 0.1]);
            mat4RotateZ(pauldronLeftMv, pauldronLeftMv, Math.PI / 3);
            mat4Scale(pauldronLeftMv, pauldronLeftMv, [1.4, 1.4, 1.4]);
            mat4Multiply(pauldronLeftMv, baseMv, pauldronLeftMv);
            setMatricesAndDraw(pauldronLeftMv, pauldronB, pauldron.indices.length, pauldronColor, 16.0);

            mat4Identity(partMv);
            mat4Translate(partMv, partMv, [0.4, 0.52, 0]);
            mat4Scale(partMv, partMv, [1.0, 0.8, 1.0]);
            mat4Multiply(partMv, baseMv, partMv);
            setMatricesAndDraw(partMv, shoulderB, shoulder.indices.length, bodyColor, 8.0);

            const pauldronRightMv = mat4Create();
            mat4Identity(pauldronRightMv);
            mat4Translate(pauldronRightMv, pauldronRightMv, [0.4, 0.47, 0.0]);
            mat4RotateZ(pauldronRightMv, pauldronRightMv, -Math.PI / 0.7);
            mat4Scale(pauldronRightMv, pauldronRightMv, [1.4, 1.4, 1.4]);
            mat4Multiply(pauldronRightMv, baseMv, pauldronRightMv);
            setMatricesAndDraw(pauldronRightMv, pauldronB, pauldron.indices.length, pauldronColor, 16.0);

            mat4Identity(partMv);
            mat4Translate(partMv, partMv, [-0.4, 0.44, 0.3]); 
            mat4RotateZ(partMv, partMv, 0.3); 
            mat4RotateX(partMv, partMv, -1.6 + currentWalkAngle - currentPunchOffset); 
            mat4Multiply(partMv, baseMv, partMv); 
            setMatricesAndDraw(partMv, armB, arm.indices.length, bodyColor, 8.0);
            
            mat4Identity(gloveMv); 
            mat4Translate(gloveMv, gloveMv, [0, -0.4, 0]); 
            mat4Multiply(gloveMv, partMv, gloveMv); 
            setMatricesAndDraw(gloveMv, gloveB, glove.indices.length, gloveColor, 16.0);

            mat4Identity(partMv);
            mat4Translate(partMv, partMv, [0.6, 0.1, 0.0]);
            mat4RotateZ(partMv, partMv, 0.5);
            mat4RotateX(partMv, partMv, 0 - currentWalkAngle); 
            mat4Multiply(partMv, baseMv, partMv);
            setMatricesAndDraw(partMv, armB, arm.indices.length, bodyColor, 8.0);

            mat4Identity(gloveMv);
            mat4Translate(gloveMv, gloveMv, [0, -0.4, 0]);
            mat4Multiply(gloveMv, partMv, gloveMv);
            setMatricesAndDraw(gloveMv, gloveB, glove.indices.length, gloveColor, 16.0);
            
            mat4Identity(partMv);
            mat4Translate(partMv, partMv, [-0.25, -1.15, 0]); 
            mat4RotateX(partMv, partMv, currentWalkAngle); 
            mat4Multiply(partMv, baseMv, partMv);
            setMatricesAndDraw(partMv, legB, leg.indices.length, bodyColor, 8.0);
            
            mat4Identity(gloveMv); 
            mat4Translate(gloveMv, gloveMv, [0, -0.4, 0.05]); 
            mat4Multiply(gloveMv, partMv, gloveMv);
            setMatricesAndDraw(gloveMv, footB, foot.indices.length, tunicColor, 8.0);

            mat4Identity(partMv);
            mat4Translate(partMv, partMv, [0.25, -1.15, 0]);
            mat4RotateX(partMv, partMv, -currentWalkAngle); 
            mat4Multiply(partMv, baseMv, partMv);
            setMatricesAndDraw(partMv, legB, leg.indices.length, bodyColor, 8.0);

            mat4Identity(gloveMv);
            mat4Translate(gloveMv, gloveMv, [0, -0.4, 0.05]);
            mat4Multiply(gloveMv, partMv, gloveMv);
            setMatricesAndDraw(gloveMv, footB, foot.indices.length, tunicColor, 8.0);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>