<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <title>WebGL Hitmonlee</title>
    <style>
        body { margin: 0; overflow: hidden; background: white; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="glcanvas"></canvas>

    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec4 a_position;
        attribute vec4 a_color;
        attribute vec3 a_normal;

        uniform mat4 u_modelMatrix;
        uniform mat4 u_viewMatrix;
        uniform mat4 u_projectionMatrix;
        uniform mat3 u_normalMatrix;
        uniform vec3 u_lightDirection;
        uniform vec3 u_viewPosition;

        varying vec4 v_color;
        varying vec3 v_normal;
        varying vec3 v_surfaceToLight;
        varying vec3 v_surfaceToView;

        void main() {
            vec4 worldPosition = u_modelMatrix * a_position;
            gl_Position = u_projectionMatrix * u_viewMatrix * worldPosition;
            v_color = a_color;
            v_normal = u_normalMatrix * a_normal;
            v_surfaceToLight = u_lightDirection;
            v_surfaceToView = u_viewPosition - worldPosition.xyz;
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;

        varying vec4 v_color;
        varying vec3 v_normal;
        varying vec3 v_surfaceToLight;
        varying vec3 v_surfaceToView;

        uniform vec4 u_ambientLightColor;
        uniform vec4 u_diffuseColor;
        uniform vec4 u_specularColor;
        uniform float u_shininess;

        void main() {
            vec3 normal = normalize(v_normal);
            vec3 surfaceToLight = normalize(v_surfaceToLight);
            vec3 surfaceToView = normalize(v_surfaceToView);
            
            vec4 ambient = u_ambientLightColor * v_color;

            float diffuseFactor = max(dot(normal, surfaceToLight), 0.0);
            vec4 diffuse = u_diffuseColor * v_color * diffuseFactor;

            vec4 specular = vec4(0.0, 0.0, 0.0, 1.0);
            if (diffuseFactor > 0.0) {
                vec3 halfVector = normalize(surfaceToLight + surfaceToView);
                float specularFactor = pow(max(dot(normal, halfVector), 0.0), u_shininess);
                specular = u_specularColor * specularFactor;
            }
            
            gl_FragColor = ambient + diffuse + specular;
            gl_FragColor.a = v_color.a;
        }
    </script>

    <script>
    // FUNGSI SETUP WEBGL 
    function setupWebGL(canvas) {
        const gl = canvas.getContext("webgl");
        if (!gl) {
            alert("WebGL tidak didukung!");
            return null;
        }
        const vsSource = document.getElementById("vertex-shader").text;
        const fsSource = document.getElementById("fragment-shader").text;
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
        const shaderProgram = createProgram(gl, vertexShader, fragmentShader);
        return { gl, shaderProgram };
    }

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error("Error kompilasi shader:", gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error("Error linking program:", gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
            return null;
        }
        return program;
    }

    function createBuffer(gl, data, type = gl.ARRAY_BUFFER) {
        const buffer = gl.createBuffer();
        gl.bindBuffer(type, buffer);
        gl.bufferData(type, data, gl.STATIC_DRAW);
        return buffer;
    }

    function createBuffersForGeometry(gl, geometry) {
        return {
            position: createBuffer(gl, geometry.vertices),
            color: createBuffer(gl, geometry.colors),
            normal: createBuffer(gl, geometry.normals),
            indices: createBuffer(gl, geometry.indices, gl.ELEMENT_ARRAY_BUFFER),
            numVertices: geometry.indices.length,
        };
    }

    // LIBRARY MATRIX
    const mat4 = {
        create: () => new Float32Array(16),
        clone: (out, a) => {
            for (let i = 0; i < 16; i++) out[i] = a[i];
            return out;
        },
        identity: (out) => {
            out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
            out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
            return out;
        },
        multiply: (out, a, b) => {
            let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
            let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
            let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
            let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
            let b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3];
            let b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7];
            let b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11];
            let b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15];
            out[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
            out[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
            out[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
            out[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
            out[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
            out[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
            out[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
            out[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
            out[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
            out[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
            out[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
            out[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
            out[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
            out[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
            out[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
            out[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;
            return out;
        },
        translate: (out, a, v) => {
            let x = v[0], y = v[1], z = v[2];
            if (a === out) {
                out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
            } else {
                mat4.clone(out, a);
                out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
            }
            return out;
        },
        rotateX: (out, a, rad) => {
            let s = Math.sin(rad), c = Math.cos(rad);
            let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
            let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
            if (a !== out) {
                out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
                out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
            }
            out[4] = a10 * c + a20 * s;
            out[5] = a11 * c + a21 * s;
            out[6] = a12 * c + a22 * s;
            out[7] = a13 * c + a23 * s;
            out[8] = a20 * c - a10 * s;
            out[9] = a21 * c - a11 * s;
            out[10] = a22 * c - a12 * s;
            out[11] = a23 * c - a13 * s;
            return out;
        },
        rotateY: (out, a, rad) => {
            let s = Math.sin(rad), c = Math.cos(rad);
            let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
            let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
            if (a !== out) {
                out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
                out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
            }
            out[0] = a00 * c - a20 * s;
            out[1] = a01 * c - a21 * s;
            out[2] = a02 * c - a22 * s;
            out[3] = a03 * c - a23 * s;
            out[8] = a00 * s + a20 * c;
            out[9] = a01 * s + a21 * c;
            out[10] = a02 * s + a22 * c;
            out[11] = a03 * s + a23 * c;
            return out;
        },
        rotateZ: (out, a, rad) => {
            let s = Math.sin(rad), c = Math.cos(rad);
            let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
            let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
            if (a !== out) {
                out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
                out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
            }
            out[0] = a00 * c + a10 * s;
            out[1] = a01 * c + a11 * s;
            out[2] = a02 * c + a12 * s;
            out[3] = a03 * c + a13 * s;
            out[4] = a10 * c - a00 * s;
            out[5] = a11 * c - a01 * s;
            out[6] = a12 * c - a02 * s;
            out[7] = a13 * c - a03 * s;
            return out;
        },
        scale: (out, a, v) => {
            let x = v[0], y = v[1], z = v[2];
            out[0] = a[0] * x; out[1] = a[1] * x; out[2] = a[2] * x; out[3] = a[3] * x;
            out[4] = a[4] * y; out[5] = a[5] * y; out[6] = a[6] * y; out[7] = a[7] * y;
            out[8] = a[8] * z; out[9] = a[9] * z; out[10] = a[10] * z; out[11] = a[11] * z;
            out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
            return out;
        },
        lookAt: (out, eye, center, up) => {
            let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
            let eyex = eye[0], eyey = eye[1], eyez = eye[2];
            let upx = up[0], upy = up[1]; let upz = up[2];
            let centerx = center[0], centery = center[1], centerz = center[2];
            z0 = eyex - centerx; z1 = eyey - centery; z2 = eyez - centerz;
            len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
            z0 *= len; z1 *= len; z2 *= len;
            x0 = upy * z2 - upz * z1;
            x1 = upz * z0 - upx * z2;
            x2 = upx * z1 - upy * z0;
            len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
            if (len) { len = 1 / len; x0 *= len; x1 *= len; x2 *= len; }
            y0 = z1 * x2 - z2 * x1;
            y1 = z2 * x0 - z0 * x2;
            y2 = z0 * x1 - z1 * x0;
            len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
            if (len) { len = 1 / len; y0 *= len; y1 *= len; y2 *= len; }
            out[0] = x0; out[1] = y0; out[2] = z0; out[3] = 0;
            out[4] = x1; out[5] = y1; out[6] = z1; out[7] = 0;
            out[8] = x2; out[9] = y2; out[10] = z2; out[11] = 0;
            out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
            out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
            out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
            out[15] = 1;
            return out;
        },
        perspective: (out, fovy, aspect, near, far) => {
            let f = 1.0 / Math.tan(fovy / 2);
            let nf = 1 / (near - far);
            out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0; out[10] = (far + near) * nf; out[11] = -1;
            out[12] = 0; out[13] = 0; out[14] = (2 * far * near) * nf; out[15] = 0;
            return out;
        }
    };

    const mat3 = {
        create: () => new Float32Array(9),
        normalFromMat4: (out, a) => {
            let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
            let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
            let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
            let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
            let b00 = a00 * a11 - a01 * a10;
            let b01 = a00 * a12 - a02 * a10;
            let b02 = a00 * a13 - a03 * a10;
            let b03 = a01 * a12 - a02 * a11;
            let b04 = a01 * a13 - a03 * a11;
            let b05 = a02 * a13 - a03 * a12;
            let b06 = a20 * a31 - a21 * a30;
            let b07 = a20 * a32 - a22 * a30;
            let b08 = a20 * a33 - a23 * a30;
            let b09 = a21 * a32 - a22 * a31;
            let b10 = a21 * a33 - a23 * a31;
            let b11 = a22 * a33 - a23 * a32;
            let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            if (!det) return null;
            det = 1.0 / det;
            out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
            out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
            out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
            out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
            out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
            out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
            out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
            out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
            out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
            return out;
        }
    };

    // FUNGSI GEOMETRI
    function createSphere(r, lat, lon, color) {
        let vertices = [], normals = [], colors = [], indices = [];
        for (let i = 0; i <= lat; i++) {
            let theta = i * Math.PI / lat;
            let sinTheta = Math.sin(theta);
            let cosTheta = Math.cos(theta);
            for (let j = 0; j <= lon; j++) {
                let phi = j * 2 * Math.PI / lon;
                let sinPhi = Math.sin(phi);
                let cosPhi = Math.cos(phi);
                let x = cosPhi * sinTheta;
                let y = cosTheta;
                let z = sinPhi * sinTheta;
                vertices.push(r * x, r * y, r * z);
                normals.push(x, y, z);
                colors.push(...color);
            }
        }
        for (let i = 0; i < lat; i++) {
            for (let j = 0; j < lon; j++) {
                let first = i * (lon + 1) + j;
                let second = first + lon + 1;
                indices.push(first, second, first + 1);
                indices.push(second, second + 1, first + 1);
            }
        }
        return {
            vertices: new Float32Array(vertices),
            normals: new Float32Array(normals),
            colors: new Float32Array(colors),
            indices: new Uint16Array(indices)
        };
    }

    function createCylinder(r, h, seg, color) {
        let vertices = [], normals = [], colors = [], indices = [];
        for (let i = 0; i <= seg; i++) {
            let theta = i * 2 * Math.PI / seg;
            let x = r * Math.cos(theta);
            let z = r * Math.sin(theta);
            vertices.push(x, h / 2, z, x, -h / 2, z);
            let nx = Math.cos(theta);
            let nz = Math.sin(theta);
            normals.push(nx, 0, nz, nx, 0, nz);
            colors.push(...color, ...color);
        }
        for (let i = 0; i < seg; i++) {
            let idx = i * 2;
            indices.push(idx, idx + 2, idx + 1);
            indices.push(idx + 1, idx + 2, idx + 3);
        }
        return {
            vertices: new Float32Array(vertices),
            normals: new Float32Array(normals),
            colors: new Float32Array(colors),
            indices: new Uint16Array(indices)
        };
    }

    function createTorus(R, r, seg, tube, color) {
        let vertices = [], normals = [], colors = [], indices = [];
        for (let i = 0; i <= seg; i++) {
            let theta = i * 2 * Math.PI / seg;
            for (let j = 0; j <= tube; j++) {
                let phi = j * 2 * Math.PI / tube;
                let x = (R + r * Math.cos(phi)) * Math.cos(theta);
                let y = r * Math.sin(phi);
                let z = (R + r * Math.cos(phi)) * Math.sin(theta);
                vertices.push(x, y, z);
                let nx = Math.cos(phi) * Math.cos(theta);
                let ny = Math.sin(phi);
                let nz = Math.cos(phi) * Math.sin(theta);
                normals.push(nx, ny, nz);
                colors.push(...color);
            }
        }
        for (let i = 0; i < seg; i++) {
            for (let j = 0; j < tube; j++) {
                let idx = i * (tube + 1) + j;
                let next = idx + tube + 1;
                indices.push(idx, next, idx + 1);
                indices.push(idx + 1, next, next + 1);
            }
        }
        return {
            vertices: new Float32Array(vertices),
            normals: new Float32Array(normals),
            colors: new Float32Array(colors),
            indices: new Uint16Array(indices)
        };
    }

    function createCone(r, h, seg, color) {
        let vertices = [], normals = [], colors = [], indices = [];
        vertices.push(0, h, 0);
        normals.push(0, 1, 0); 
        colors.push(...color);
        for (let i = 0; i <= seg; i++) {
            let theta = i * 2 * Math.PI / seg;
            let x = r * Math.cos(theta);
            let z = r * Math.sin(theta);
            vertices.push(x, 0, z);
            // Normal untuk sisi kerucut
            let n = [x, r / h, z];
            let len = Math.sqrt(n[0]*n[0] + n[1]*n[1] + n[2]*n[2]);
            normals.push(n[0]/len, n[1]/len, n[2]/len);
            colors.push(...color);
        }
        for (let i = 1; i <= seg; i++) {
            indices.push(0, i, i + 1);
        }
        // Tambahkan alas
        let baseCenterIndex = vertices.length / 3;
        vertices.push(0, 0, 0);
        normals.push(0, -1, 0);
        colors.push(...color);
        for (let i = 1; i <= seg; i++) {
            indices.push(baseCenterIndex, i + 1, i);
        }
        
        return {
            vertices: new Float32Array(vertices),
            normals: new Float32Array(normals),
            colors: new Float32Array(colors),
            indices: new Uint16Array(indices)
        };
    }

    function createCube(size, color) {
        let s = size / 2;
        let vertices = [
            -s, -s, -s,  s, -s, -s,  s,  s, -s, -s,  s, -s, // depan
            -s, -s,  s,  s, -s,  s,  s,  s,  s, -s,  s,  s, // belakang
            -s,  s, -s, -s,  s,  s,  s,  s,  s,  s,  s, -s, // atas
            -s, -s, -s, -s, -s,  s,  s, -s,  s,  s, -s, -s, // bawah
            -s, -s, -s, -s, -s,  s, -s,  s,  s, -s,  s, -s, // kiri
             s, -s, -s,  s, -s,  s,  s,  s,  s,  s,  s, -s  // kanan
        ];
        
        let normals = [
             0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1, // depan
             0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1, // belakang
             0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0, // atas
             0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0, // bawah
            -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, // kiri
             1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0  // kanan
        ];
        
        let colors = [];
        for (let i = 0; i < vertices.length / 3; i++) {
            colors.push(...color);
        }
        
        let indices = [
             0, 1, 2,  0, 2, 3,  // depan
             4, 6, 5,  4, 7, 6,  // belakang
             8, 9, 10, 8, 10, 11, // atas
             12, 14, 13, 12, 15, 14, // bawah
             16, 18, 17, 16, 19, 18, // kiri
             20, 21, 22, 20, 22, 23  // kanan
        ];
        
        return {
            vertices: new Float32Array(vertices),
            normals: new Float32Array(normals),
            colors: new Float32Array(colors),
            indices: new Uint16Array(indices)
        };
    }

    function createEllipsoid(rx, ry, rz, lat, lon, color) {
        let vertices = [], normals = [], colors = [], indices = [];
        for (let i = 0; i <= lat; i++) {
            let theta = i * Math.PI / lat;
            let sinTheta = Math.sin(theta);
            let cosTheta = Math.cos(theta);
            for (let j = 0; j <= lon; j++) {
                let phi = j * 2 * Math.PI / lon;
                let sinPhi = Math.sin(phi);
                let cosPhi = Math.cos(phi);
                let x = cosPhi * sinTheta;
                let y = cosTheta;
                let z = sinPhi * sinTheta;
                vertices.push(rx * x, ry * y, rz * z);
                // Normal untuk ellipsoid
                normals.push(x / rx, y / ry, z / rz);
                colors.push(...color);
            }
        }
        for (let i = 0; i < lat; i++) {
            for (let j = 0; j < lon; j++) {
                let first = i * (lon + 1) + j;
                let second = first + lon + 1;
                indices.push(first, second, first + 1);
                indices.push(second, second + 1, first + 1);
            }
        }
        return {
            vertices: new Float32Array(vertices),
            normals: new Float32Array(normals),
            colors: new Float32Array(colors),
            indices: new Uint16Array(indices)
        };
    }

    function createTriangle(size, color) {
        let s = size / 2.0;
        let vertices = [
            // x,   y,   z
            // REVISI: Mengubah 3 vertex untuk
            // membuat segitiga siku-siku.
            // Sudut 90 derajat ada di 'bawah kiri' (-s, -s).
            -s, -s, 0.2, // Sudut siku-siku (bawah kiri)
             s, -s, 0.2, // Bawah kanan
            -s,  s, 0.2  // Atas kiri
        ];
        let normals = [
            0.0, .0, 1.0, // semua menghadap depan (sumbu Z+)
            0.0, 0.0, 1.0,
            0.0, 0.0, 1.0
        ];
        let colors = [
            ...color, ...color, ...color
        ];
        let indices = [0, 1, 2]; // Satu segitiga
        
        return {
            vertices: new Float32Array(vertices),
            normals: new Float32Array(normals),
            colors: new Float32Array(colors),
            indices: new Uint16Array(indices)
        };
    }

    // FUNGSI GAMBAR
    function drawObject(gl, programInfo, buffers, modelMatrix, normalMatrix, specularColor, shininess) {
        gl.uniformMatrix4fv(programInfo.uniformLocations.modelMatrix, false, modelMatrix);
        gl.uniformMatrix3fv(programInfo.uniformLocations.normalMatrix, false, normalMatrix);
        gl.uniform4fv(programInfo.uniformLocations.specularColor, specularColor);
        gl.uniform1f(programInfo.uniformLocations.shininess, shininess);

        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
        gl.vertexAttribPointer(programInfo.attribLocations.position, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(programInfo.attribLocations.position);

        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
        gl.vertexAttribPointer(programInfo.attribLocations.color, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(programInfo.attribLocations.color);

        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal);
        gl.vertexAttribPointer(programInfo.attribLocations.normal, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(programInfo.attribLocations.normal);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);
        gl.drawElements(gl.TRIANGLES, buffers.numVertices, gl.UNSIGNED_SHORT, 0);
    }

    // FUNGSI UTAMA 
    function main() {
        const canvas = document.getElementById('glcanvas');
        const { gl, shaderProgram } = setupWebGL(canvas);
        if (!gl) return;

        // Variabel untuk Interaksi 
        let cameraDistance = 8.0; // Untuk Zoom
        let rotationX = 0.3; // Rotasi awal
        let rotationY = 0;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        // Variabel untuk Siklus Animasi Otomatis 
        let currentAnimationIndex = 0; // Mulai dari animasi Idle (0)
        let isAnimationPaused = false; // Status animasi (true = berhenti, false = jalan)
        const animationOrder = [0, 1, 3, 4, 5, 6]; // Urutan animasi yang akan dijalankan
        const animationDuration = 5000; // Durasi setiap animasi dalam milidetik (misal: 5 detik)
        let lastAnimationSwitchTime = performance.now();
        console.log("Animasi akan berganti otomatis setiap 5 detik.");

        const projectionMatrix = mat4.create(); 

        // Fungsi untuk handle resize
        function handleResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            const aspect = canvas.width / canvas.height;
            mat4.perspective(projectionMatrix, Math.PI / 4, aspect, 0.1, 100.0);
            gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);
        }

        // Program Info
        const programInfo = {
            program: shaderProgram,
            attribLocations: {
                position: gl.getAttribLocation(shaderProgram, 'a_position'),
                color: gl.getAttribLocation(shaderProgram, 'a_color'),
                normal: gl.getAttribLocation(shaderProgram, 'a_normal'),
            },
            uniformLocations: {
                modelMatrix: gl.getUniformLocation(shaderProgram, 'u_modelMatrix'),
                viewMatrix: gl.getUniformLocation(shaderProgram, 'u_viewMatrix'),
                projectionMatrix: gl.getUniformLocation(shaderProgram, 'u_projectionMatrix'),
                normalMatrix: gl.getUniformLocation(shaderProgram, 'u_normalMatrix'),
                lightDirection: gl.getUniformLocation(shaderProgram, 'u_lightDirection'),
                viewPosition: gl.getUniformLocation(shaderProgram, 'u_viewPosition'),
                ambientLightColor: gl.getUniformLocation(shaderProgram, 'u_ambientLightColor'),
                diffuseColor: gl.getUniformLocation(shaderProgram, 'u_diffuseColor'),
                specularColor: gl.getUniformLocation(shaderProgram, 'u_specularColor'),
                shininess: gl.getUniformLocation(shaderProgram, 'u_shininess'),
            }
        };

        gl.useProgram(shaderProgram);

        // Warna
        const brownColor = [0.65, 0.45, 0.25, 1.0]; 
        const creamColor = [0.95, 0.9, 0.7, 1.0];
        const yellowColor = [0.95, 0.8, 0.2, 1.0]; 
        const whiteColor = [1.0, 1.0, 1.0, 1.0]; 
        const blackColor = [0.05, 0.05, 0.05, 1.0];
        const bandageYellowColor = [0.90, 0.75, 0.15, 1.0]; // Warna kuning perban

        // Geometri 
        const bodyBuffers = createBuffersForGeometry(gl, createEllipsoid(0.5, 0.75, 0.4, 16, 16, brownColor));
        const shoulderBuffers = createBuffersForGeometry(gl, createSphere(0.15, 12, 12, brownColor));
        const upperArmBuffers = createBuffersForGeometry(gl, createCylinder(0.12, 0.4, 12, brownColor));
        const elbowBuffers = createBuffersForGeometry(gl, createSphere(0.11, 12, 12, brownColor));
        const forearmBuffers = createBuffersForGeometry(gl, createCylinder(0.1, 0.35, 12, brownColor));
        const handBuffers = createBuffersForGeometry(gl, createSphere(0.13, 12, 12, brownColor));
        const fingerBuffers = createBuffersForGeometry(gl, createCylinder(0.03, 0.12, 8, brownColor));
        const thighBuffers = createBuffersForGeometry(gl, createCylinder(0.28, 0.65, 12, brownColor));
        const kneeBuffers = createBuffersForGeometry(gl, createSphere(0.18, 12, 12, brownColor));
        const calfBuffers = createBuffersForGeometry(gl, createCylinder(0.17, 0.6, 12, brownColor)); 
        const footBuffers = createBuffersForGeometry(gl, createCube(1.0, brownColor)); 
        const clawBuffers = createBuffersForGeometry(gl, createCone(0.04, 0.1, 8, [0.7, 0.7, 0.7, 1.0]));
        const bandageBuffers = createBuffersForGeometry(gl, createTorus(0.17, 0.05, 16, 8, creamColor));
        const armBandageBuffers = createBuffersForGeometry(gl, createTorus(0.10, 0.03, 16, 8, creamColor)); 
        const bandageLineBuffers = createBuffersForGeometry(gl, createTorus(0.10, 0.015, 16, 8, blackColor)); 
        const yellowBandageBuffers = createBuffersForGeometry(gl, createTorus(0.10, 0.035, 16, 8, bandageYellowColor)); 
        const yellowBandageLineBuffers = createBuffersForGeometry(gl, createTorus(0.10, 0.008, 16, 8, blackColor)); 
        const calfSegmentBuffers = createBuffersForGeometry(gl, createEllipsoid(0.17, 0.06, 0.17, 16, 16, creamColor)); 
        const calfSegmentLineBuffers = createBuffersForGeometry(gl, createEllipsoid(0.175, 0.01, 0.175, 16, 16, blackColor)); 
        const ankleGuardBuffers = createBuffersForGeometry(gl, createSphere(0.06, 10, 10, yellowColor));
        const eyeMaskBuffers = createBuffersForGeometry(gl, createEllipsoid(0.1, 0.06, 0.01, 16, 16, blackColor));
        const pupilBuffers = createBuffersForGeometry(gl, createEllipsoid(0.03, 0.06, 0.03, 12, 12, whiteColor)); 
        const irisBuffers = createBuffersForGeometry(gl, createSphere(0.03, 8, 8, blackColor));

        // Setup Pencahayaan
        const lightDirection = new Float32Array([0.5, 0.7, 1.0]);
        const ambientLightColor = new Float32Array([0.3, 0.3, 0.3, 1.0]);
        const diffuseColor = new Float32Array([0.8, 0.8, 0.8, 1.0]);

        gl.uniform3fv(programInfo.uniformLocations.lightDirection, lightDirection);
        gl.uniform4fv(programInfo.uniformLocations.ambientLightColor, ambientLightColor);
        gl.uniform4fv(programInfo.uniformLocations.diffuseColor, diffuseColor);

        // Setup Kamera & Resize
        handleResize(); 
        window.addEventListener('resize', handleResize); 

        gl.enable(gl.DEPTH_TEST);
        gl.clearColor(1.0, 1.0, 1.0, 1.0);

        // Event Listeners untuk Interaksi 

        // Zoom (Scroll)
        canvas.addEventListener('wheel', event => {
            event.preventDefault();
            cameraDistance += event.deltaY * 0.01;
            cameraDistance = Math.max(2.0, Math.min(20.0, cameraDistance)); // Batasi zoom
        });

        // Rotasi (Drag)
        canvas.addEventListener('mousedown', event => {
            isDragging = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        });

        // Event Listener untuk Pause/Resume Animasi 
        window.addEventListener('keydown', event => {
        if (event.code === 'Space') { // Cek jika tombol Spasi ditekan
        event.preventDefault(); // Mencegah scroll halaman jika spasi ditekan
        isAnimationPaused = !isAnimationPaused; // Toggle status pause
        console.log("Animasi " + (isAnimationPaused ? "diberhentikan." : "dilanjutkan."));
        }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        canvas.addEventListener('mousemove', event => {
            if (!isDragging) return;
            const deltaX = event.clientX - lastMouseX;
            const deltaY = event.clientY - lastMouseY;
            
            rotationY += deltaX * 0.01;
            rotationX += deltaY * 0.01;
            
            rotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationX)); 

            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        });


        // Fungsi Render
        function render() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Update Waktu 
            let time = performance.now() * 0.001; // Waktu dalam detik

            // Logika Pergantian Animasi Otomatis 
            let currentTime = performance.now();
            if (!isAnimationPaused) { // Hanya update jika tidak dipause
            if (currentTime - lastAnimationSwitchTime > animationDuration) {
                currentAnimationIndex = (currentAnimationIndex + 1) % animationOrder.length;
                lastAnimationSwitchTime = currentTime;
                console.log("Mengganti ke animasi: " + animationOrder[currentAnimationIndex]);
            }
            } 
            const currentAnimation = animationOrder[currentAnimationIndex];
    
            // TAMBAHAN: Logika Animasi 
            let leftThighRot = 0;
            let leftKneeRot = 0;
            let rightThighRot = 0;
            let rightKneeRot = 0;
            let leftArmRot = 0;
            let leftElbowRot = 0;
            let rightArmRot = 0;
            let rightElbowRot = 0;
            let bodyBob = 0;
            // Animasi berkedip (selalu aktif)
            let eyeScaleY = (Math.cos(time * 3.0) > 0.98) ? 0.1 : 1.0; 

            switch (currentAnimation) {
                case 1: // Kombo Tendang/Pukul Bergantian
                    {
                        let animSpeed = 2.5;
                        let cycle = Math.sin(time * animSpeed); // -1 to 1
                        let kickAngle = Math.max(0, cycle) * 1.5; // 0 to 1.5
                        let punchAngle = Math.max(0, cycle) * 1.2;
                        let oppositeKick = Math.max(0, -cycle) * 1.5;
                        let oppositePunch = Math.max(0, -cycle) * 1.2;

                        // Kaki Kiri Tendang, Tangan Kanan Pukul
                        leftThighRot = kickAngle;
                        leftKneeRot = -kickAngle * 0.7; // Luruskan lutut
                        rightArmRot = punchAngle; // Tangan maju
                        rightElbowRot = -punchAngle * 0.8; // Siku lurus

                        // Kaki Kanan Tendang, Tangan Kiri Pukul
                        rightThighRot = oppositeKick;
                        rightKneeRot = -oppositeKick * 0.7;
                        leftArmRot = oppositePunch;
                        leftElbowRot = -oppositePunch * 0.8;
                    }
                    break;
                
                case 3: // Jalan di Tempat
                    {
                        let walkSpeed = 3.0;
                        let walkCycle = Math.sin(time * walkSpeed);
                        leftThighRot = walkCycle * 0.4;
                        leftKneeRot = -Math.abs(walkCycle * 0.5); // Lutut nekuk
                        rightThighRot = -walkCycle * 0.4;
                        rightKneeRot = -Math.abs(walkCycle * 0.5);
                        
                        leftArmRot = -walkCycle * 0.3; // Tangan berayun
                        rightArmRot = walkCycle * 0.3;
                        
                        bodyBob = (Math.abs(walkCycle) - 0.5) * -0.1; // Badan naik turun
                    }
                    break;

                case 4: // Lari di Tempat
                    {
                        let runSpeed = 8.0;
                        let runCycle = Math.sin(time * runSpeed);
                        leftThighRot = runCycle * 0.8;
                        leftKneeRot = -Math.abs(runCycle * 1.2); // Lutut nekuk lebih banyak
                        rightThighRot = -runCycle * 0.8;
                        rightKneeRot = -Math.abs(runCycle * 1.2);
                        
                        leftArmRot = -runCycle * 0.6; // Tangan ayun lebih cepat
                        leftElbowRot = -Math.abs(runCycle * 0.5); // Siku juga nekuk
                        rightArmRot = runCycle * 0.6;
                        rightElbowRot = -Math.abs(runCycle * 0.5);
                        
                        bodyBob = (Math.abs(runCycle) - 0.5) * -0.15; // Badan naik turun lebih
                    }
                    break;

                case 5: // Tinju Bergantian
                    {
                        let punchSpeed = 5.0;
                        let punchCycle = Math.sin(time * punchSpeed);
                        leftArmRot = Math.max(0, punchCycle) * 1.2;
                        leftElbowRot = -Math.max(0, punchCycle) * 0.8;
                        rightArmRot = Math.max(0, -punchCycle) * 1.2;
                        rightElbowRot = -Math.max(0, -punchCycle) * 0.8;
                    }
                    break;
                    
                case 6: // Tendang Bergantian
                    {
                        let kickSpeed = 4.0;
                        let kickCycle = Math.sin(time * kickSpeed);
                        leftThighRot = Math.max(0, kickCycle) * 1.5;
                        leftKneeRot = -Math.max(0, kickCycle) * 0.7;
                        rightThighRot = Math.max(0, -kickCycle) * 1.5;
                        rightKneeRot = -Math.max(0, -kickCycle) * 0.7;
                    }
                    break;

                case 0: // Idle
                default:
                    // Semua variabel rotasi = 0 (default)
                    // Hanya mata berkedip
                    break;
            }

            // Reset ke Idle jika dipause 
            if (isAnimationPaused) {
            leftThighRot = 0; leftKneeRot = 0;
            rightThighRot = 0; rightKneeRot = 0;
            leftArmRot = 0; leftElbowRot = 0;
            rightArmRot = 0; rightElbowRot = 0;
            bodyBob = 0;
            // Biarkan eyeScaleY tetap berkedip saat idle/pause
            time = performance.now() * 0.001; // Tetap update time untuk kedip
            eyeScaleY = (Math.cos(time * 3.0) > 0.98) ? 0.1 : 1.0;
            }

            // Update View Matrix & View Position
            const viewMatrix = mat4.create();
            const eyePosition = [
                cameraDistance * Math.sin(rotationY) * Math.cos(rotationX),
                cameraDistance * Math.sin(rotationX),
                cameraDistance * Math.cos(rotationY) * Math.cos(rotationX)
            ];
            mat4.lookAt(viewMatrix, eyePosition, [0, 0, 0], [0, 1, 0]);
            gl.uniformMatrix4fv(programInfo.uniformLocations.viewMatrix, false, viewMatrix);
            gl.uniform3fv(programInfo.uniformLocations.viewPosition, eyePosition);


            const specularColor = new Float32Array([0.3, 0.3, 0.3, 1.0]);
            const shininess = 32.0;
            const noSpecular = new Float32Array([0.0, 0.0, 0.0, 1.0]);
            const lowShininess = 5.0;

            // Global model matrix
            const globalModelMatrix = mat4.create();
            mat4.identity(globalModelMatrix);

            const tempMatrix = mat4.create();
            const tempMatrix2 = mat4.create();
            const normalMatrix = mat3.create();

            // Badan & Kepala (Diperbesar)
            mat4.clone(tempMatrix, globalModelMatrix);
            mat4.translate(tempMatrix, tempMatrix, [0.0, -0.15, 0.0]);
            mat4.translate(tempMatrix, tempMatrix, [0.0, bodyBob, 0.0]); 
            mat4.rotateX(tempMatrix, tempMatrix, -0.10);
            mat4.scale(tempMatrix, tempMatrix, [1.8, 1.8, 1.69]); 
            mat3.normalFromMat4(normalMatrix, tempMatrix);
            drawObject(gl, programInfo, bodyBuffers, tempMatrix, normalMatrix, specularColor, shininess);

            // Mata 
            // Mata kiri (Masker Hitam - BENTUK ELIPS)
            mat4.clone(tempMatrix2, tempMatrix);
            mat4.translate(tempMatrix2, tempMatrix2, [-0.18, 0.40, 0.35]); 
            mat4.rotateZ(tempMatrix2, tempMatrix2, -0.25); 
            mat4.scale(tempMatrix2, tempMatrix2, [1.7, 1.5 * eyeScaleY, 1.0]); // ANIMASI KEDIP
            mat3.normalFromMat4(normalMatrix, tempMatrix2);
            drawObject(gl, programInfo, eyeMaskBuffers, tempMatrix2, normalMatrix, noSpecular, lowShininess);

            // Simpan matriks masker mata kiri untuk pupil & iris
            let leftEyeMatrix = mat4.clone(mat4.create(), tempMatrix2);

            // Pupil kiri (Putih / Sclera)
            mat4.clone(tempMatrix2, leftEyeMatrix); 
            mat4.translate(tempMatrix2, tempMatrix2, [0.0, 0.0, 0.02]); 
            mat4.scale(tempMatrix2, tempMatrix2, [0.7, 0.6 * eyeScaleY, 1.5]); // ANIMASI KEDIP
            mat3.normalFromMat4(normalMatrix, tempMatrix2);
            drawObject(gl, programInfo, pupilBuffers, tempMatrix2, normalMatrix, noSpecular, lowShininess);

            // Biji Mata Kiri (Hitam / Iris) 
            mat4.clone(tempMatrix2, leftEyeMatrix); 
            mat4.translate(tempMatrix2, tempMatrix2, [0.0, 0.0, 0.04]); 
            mat4.scale(tempMatrix2, tempMatrix2, [0.3, 0.4 * eyeScaleY, 1.0]); // ANIMASI KEDIP
            mat3.normalFromMat4(normalMatrix, tempMatrix2);
            drawObject(gl, programInfo, irisBuffers, tempMatrix2, normalMatrix, noSpecular, lowShininess);

            // Mata kanan (Masker Hitam - BENTUK ELIPS)
            mat4.clone(tempMatrix2, tempMatrix);
            mat4.translate(tempMatrix2, tempMatrix2, [0.18, 0.40, 0.35]); 
            mat4.rotateZ(tempMatrix2, tempMatrix2, 0.25); 
            mat4.scale(tempMatrix2, tempMatrix2, [1.7, 1.5 * eyeScaleY, 1.0]); // ANIMASI KEDIP
            mat3.normalFromMat4(normalMatrix, tempMatrix2);
            drawObject(gl, programInfo, eyeMaskBuffers, tempMatrix2, normalMatrix, noSpecular, lowShininess);

            // Simpan matriks masker mata kanan untuk pupil & iris
            let rightEyeMatrix = mat4.clone(mat4.create(), tempMatrix2); // 'let' dihapus

            // Pupil kanan (Putih / Sclera)
            mat4.clone(tempMatrix2, rightEyeMatrix); 
            mat4.translate(tempMatrix2, tempMatrix2, [0.0, 0.0, 0.02]); 
            mat4.scale(tempMatrix2, tempMatrix2, [0.7, 0.6 * eyeScaleY, 1.5]); // ANIMASI KEDIP
            mat3.normalFromMat4(normalMatrix, tempMatrix2);
            drawObject(gl, programInfo, pupilBuffers, tempMatrix2, normalMatrix, noSpecular, lowShininess);

            // Biji Mata Kanan (Hitam / Iris) 
            mat4.clone(tempMatrix2, rightEyeMatrix); 
            mat4.translate(tempMatrix2, tempMatrix2, [0.0, 0.0, 0.04]); 
            mat4.scale(tempMatrix2, tempMatrix2, [0.3, 0.4 * eyeScaleY, 1.0]); // ANIMASI KEDIP
            mat3.normalFromMat4(normalMatrix, tempMatrix2);
            drawObject(gl, programInfo, irisBuffers, tempMatrix2, normalMatrix, noSpecular, lowShininess);

            // TANGAN KIRI 
            let leftArmBase = mat4.clone(mat4.create(), globalModelMatrix);
            mat4.translate(leftArmBase, leftArmBase, [-0.90, 0.3, 0.0]); 
            mat4.rotateZ(leftArmBase, leftArmBase, -1.3); 
            mat4.rotateX(leftArmBase, leftArmBase, -0.3);
            mat4.rotateX(leftArmBase, leftArmBase, leftArmRot); // ANIMASI BAHU
            
            // Skala umum untuk memperbesar lengan (coba 1.5x)
            let armScaleFactor = 1.7;
            let armScaleVec = [armScaleFactor, armScaleFactor, armScaleFactor];

            // Bahu
            mat4.clone(tempMatrix, leftArmBase);
            mat4.scale(tempMatrix, tempMatrix, armScaleVec); 
            mat3.normalFromMat4(normalMatrix, tempMatrix);
            drawObject(gl, programInfo, shoulderBuffers, tempMatrix, normalMatrix, specularColor, shininess);

            // Lengan atas
            mat4.translate(leftArmBase, leftArmBase, [0, -0.3, 0]); 
            mat4.clone(tempMatrix, leftArmBase);
            mat4.scale(tempMatrix, tempMatrix, armScaleVec); 
            mat3.normalFromMat4(normalMatrix, tempMatrix);
            drawObject(gl, programInfo, upperArmBuffers, tempMatrix, normalMatrix, specularColor, shininess);

            // Siku
            mat4.translate(leftArmBase, leftArmBase, [0, -0.3, 0]); 
            mat4.rotateX(leftArmBase, leftArmBase, leftElbowRot); // ANIMASI SIKU
            mat4.clone(tempMatrix, leftArmBase);
            mat4.scale(tempMatrix, tempMatrix, armScaleVec); 
            mat3.normalFromMat4(normalMatrix, tempMatrix);
            drawObject(gl, programInfo, elbowBuffers, tempMatrix, normalMatrix, specularColor, shininess);

            // Lengan bawah
            mat4.rotateZ(leftArmBase, leftArmBase, -0.5);
            mat4.translate(leftArmBase, leftArmBase, [0, -0.27, 0]); 
            mat4.clone(tempMatrix, leftArmBase);
            mat4.scale(tempMatrix, tempMatrix, armScaleVec); 
            mat3.normalFromMat4(normalMatrix, tempMatrix);
            drawObject(gl, programInfo, forearmBuffers, tempMatrix, normalMatrix, specularColor, shininess);

            // PERBAN LENGAN BAWAH (SEPERTI BETIS) 
            let forearmMatrix = mat4.clone(mat4.create(), leftArmBase); 
            let bandageScaleFactor = armScaleFactor * 0.7; 
            let bandageScaleVec = [bandageScaleFactor, bandageScaleFactor, bandageScaleFactor];
            let numBandageSegments = 6; 

            for (let i = 0; i < numBandageSegments; i++) {
                // Segmen Cream (Gunakan calfSegmentBuffers)
                mat4.clone(tempMatrix2, forearmMatrix); 
                mat4.translate(tempMatrix2, tempMatrix2, [0, 0.15 - (i * 0.06), 0]); 
                mat4.scale(tempMatrix2, tempMatrix2, bandageScaleVec); 
                mat3.normalFromMat4(normalMatrix, tempMatrix2);
                drawObject(gl, programInfo, calfSegmentBuffers, tempMatrix2, normalMatrix, noSpecular, lowShininess);

                // Garis Hitam (Gunakan calfSegmentLineBuffers)
                mat4.clone(tempMatrix2, forearmMatrix); 
                mat4.translate(tempMatrix2, tempMatrix2, [0, 0.15 - (i * 0.06), 0]); 
                mat4.scale(tempMatrix2, tempMatrix2, bandageScaleVec); 
                mat3.normalFromMat4(normalMatrix, tempMatrix2);
                drawObject(gl, programInfo, calfSegmentLineBuffers, tempMatrix2, normalMatrix, noSpecular, lowShininess);
            }

            // Tangan
            mat4.translate(leftArmBase, leftArmBase, [0, -0.3, 0]); 
            mat4.clone(tempMatrix, leftArmBase);
            mat4.scale(tempMatrix, tempMatrix, armScaleVec); 
            mat3.normalFromMat4(normalMatrix, tempMatrix);
            drawObject(gl, programInfo, handBuffers, tempMatrix, normalMatrix, specularColor, shininess);

            // Jari (3 jari)
            let handMatrix = mat4.clone(mat4.create(), leftArmBase); 
            for (let i = 0; i < 3; i++) {
                mat4.clone(tempMatrix2, handMatrix); 
                let xOffset = (i - 1.0) * 0.12; 
                mat4.translate(tempMatrix2, tempMatrix2, [xOffset, -0.15, 0.0]); 
                let fingerScaleVec = [armScaleFactor * 0.8, armScaleFactor * 1.9, armScaleFactor * 2.0]; 
                mat4.scale(tempMatrix2, tempMatrix2, fingerScaleVec); 
                mat3.normalFromMat4(normalMatrix, tempMatrix2);
                drawObject(gl, programInfo, fingerBuffers, tempMatrix2, normalMatrix, specularColor, shininess);
            }

            // TANGAN KANAN 
            let rightArmBase = mat4.clone(mat4.create(), globalModelMatrix);
            mat4.translate(rightArmBase, rightArmBase, [0.90, 0.3, 0.0]); 
            mat4.rotateZ(rightArmBase, rightArmBase, 1.3); 
            mat4.rotateX(rightArmBase, rightArmBase, -0.3); 
            mat4.rotateX(rightArmBase, rightArmBase, rightArmRot); // ANIMASI BAHU
            
            // Bahu
            mat4.clone(tempMatrix, rightArmBase);
            mat4.scale(tempMatrix, tempMatrix, armScaleVec); 
            mat3.normalFromMat4(normalMatrix, tempMatrix);
            drawObject(gl, programInfo, shoulderBuffers, tempMatrix, normalMatrix, specularColor, shininess);

            // Lengan atas
            mat4.translate(rightArmBase, rightArmBase, [0, -0.3, 0]); 
            mat4.clone(tempMatrix, rightArmBase);
            mat4.scale(tempMatrix, tempMatrix, armScaleVec); 
            mat3.normalFromMat4(normalMatrix, tempMatrix);
            drawObject(gl, programInfo, upperArmBuffers, tempMatrix, normalMatrix, specularColor, shininess);

            // Siku
            mat4.translate(rightArmBase, rightArmBase, [0, -0.3, 0]); 
            mat4.rotateX(rightArmBase, rightArmBase, rightElbowRot); // ANIMASI SIKU
            mat4.clone(tempMatrix, rightArmBase);
            mat4.scale(tempMatrix, tempMatrix, armScaleVec); 
            mat3.normalFromMat4(normalMatrix, tempMatrix);
            drawObject(gl, programInfo, elbowBuffers, tempMatrix, normalMatrix, specularColor, shininess);

            // Lengan bawah
            mat4.rotateZ(rightArmBase, rightArmBase, 0.5); 
            mat4.translate(rightArmBase, rightArmBase, [0, -0.27, 0]); 
            mat4.clone(tempMatrix, rightArmBase);
            mat4.scale(tempMatrix, tempMatrix, armScaleVec); 
            mat3.normalFromMat4(normalMatrix, tempMatrix);
            drawObject(gl, programInfo, forearmBuffers, tempMatrix, normalMatrix, specularColor, shininess);

            // PERBAN LENGAN BAWAH 
            forearmMatrix = mat4.clone(mat4.create(), rightArmBase); 
            
            for (let i = 0; i < numBandageSegments; i++) {
                // Segmen Cream (Gunakan calfSegmentBuffers)
                mat4.clone(tempMatrix2, forearmMatrix); 
                mat4.translate(tempMatrix2, tempMatrix2, [0, 0.15 - (i * 0.06), 0]); 
                mat4.scale(tempMatrix2, tempMatrix2, bandageScaleVec); 
                mat3.normalFromMat4(normalMatrix, tempMatrix2);
                drawObject(gl, programInfo, calfSegmentBuffers, tempMatrix2, normalMatrix, noSpecular, lowShininess);

                // Garis Hitam (Gunakan calfSegmentLineBuffers)
                mat4.clone(tempMatrix2, forearmMatrix); 
                mat4.translate(tempMatrix2, tempMatrix2, [0, 0.15 - (i * 0.06), 0]); 
                mat4.scale(tempMatrix2, tempMatrix2, bandageScaleVec); 
                mat3.normalFromMat4(normalMatrix, tempMatrix2);
                drawObject(gl, programInfo, calfSegmentLineBuffers, tempMatrix2, normalMatrix, noSpecular, lowShininess);
            }

            // Tangan
            mat4.translate(rightArmBase, rightArmBase, [0, -0.3, 0]); 
            mat4.clone(tempMatrix, rightArmBase);
            mat4.scale(tempMatrix, tempMatrix, armScaleVec); 
            mat3.normalFromMat4(normalMatrix, tempMatrix);
            drawObject(gl, programInfo, handBuffers, tempMatrix, normalMatrix, specularColor, shininess);

            // Jari (3 jari)
            handMatrix = mat4.clone(mat4.create(), rightArmBase); 
            for (let i = 0; i < 3; i++) {
                mat4.clone(tempMatrix2, handMatrix); 
                let xOffset = (i - 1.0) * 0.12; 
                mat4.translate(tempMatrix2, tempMatrix2, [xOffset, -0.15, 0.0]); 
                let fingerScaleVec = [armScaleFactor * 0.8, armScaleFactor * 1.9, armScaleFactor * 2.0]; 
                mat4.scale(tempMatrix2, tempMatrix2, fingerScaleVec); 
                mat3.normalFromMat4(normalMatrix, tempMatrix2);
                drawObject(gl, programInfo, fingerBuffers, tempMatrix2, normalMatrix, specularColor, shininess);
            }

            // KAKI KIRI (Berdiri) 
            let leftLegBase = mat4.clone(mat4.create(), globalModelMatrix);
            mat4.translate(leftLegBase, leftLegBase, [-0.43, -0.85, 0.0]); 
            mat4.rotateX(leftLegBase, leftLegBase, -0.1); 
            mat4.rotateX(leftLegBase, leftLegBase, leftThighRot); // ANIMASI PAHA

            // Paha
            mat4.translate(leftLegBase, leftLegBase, [0, -0.28, 0]);
            mat4.clone(tempMatrix, leftLegBase);
            mat4.scale(tempMatrix, tempMatrix, [1.2, 1.7, 1.2]);
            mat3.normalFromMat4(normalMatrix, tempMatrix);
            drawObject(gl, programInfo, thighBuffers, tempMatrix, normalMatrix, specularColor, shininess);

            // Perban paha
            for (let i = 0; i < 4; i++) {
                mat4.clone(tempMatrix2, leftLegBase);
                mat4.translate(tempMatrix2, tempMatrix2, [0, 0.2 - (i * 0.12), 0]);
                mat4.rotateX(tempMatrix2, tempMatrix2, Math.PI / 2);
                mat3.normalFromMat4(normalMatrix, tempMatrix2);
                drawObject(gl, programInfo, bandageBuffers, tempMatrix2, normalMatrix, noSpecular, lowShininess);
            }

            // Lutut
            mat4.translate(leftLegBase, leftLegBase, [0, -0.28, 0]);
            mat4.rotateX(leftLegBase, leftLegBase, leftKneeRot); // ANIMASI LUTUT
            mat4.clone(tempMatrix, leftLegBase);
            mat3.normalFromMat4(normalMatrix, tempMatrix);
            drawObject(gl, programInfo, kneeBuffers, tempMatrix, normalMatrix, specularColor, shininess);

            // Betis
            mat4.rotateX(leftLegBase, leftLegBase, 0.0); 
            mat4.translate(leftLegBase, leftLegBase, [0, -0.35, 0]);
            
            let scaledCalfBase = mat4.create();
            mat4.clone(scaledCalfBase, leftLegBase);
            mat4.scale(scaledCalfBase, scaledCalfBase, [1.50, 1.70, 1.5]); 

            // Perban betis 
            for (let i = 0; i < 9; i++) { 
                let curveAmount = 0.0; 
                let xOffset = Math.sin((i / 7.0) * Math.PI) * curveAmount; 

                mat4.clone(tempMatrix2, scaledCalfBase); 
                mat4.translate(tempMatrix2, tempMatrix2, [xOffset, 0.3 - (i * 0.08), 0]); 
                mat3.normalFromMat4(normalMatrix, tempMatrix2);
                drawObject(gl, programInfo, calfSegmentBuffers, tempMatrix2, normalMatrix, noSpecular, lowShininess);
                
                mat4.clone(tempMatrix2, scaledCalfBase); 
                mat4.translate(tempMatrix2, tempMatrix2, [xOffset, 0.3 - (i * 0.08) + 0.00, 0]); 
                mat3.normalFromMat4(normalMatrix, tempMatrix2);
                drawObject(gl, programInfo, calfSegmentLineBuffers, tempMatrix2, normalMatrix, noSpecular, lowShininess);
            }

            // KAKI KIRI
            // Engkel dan kaki
            mat4.translate(leftLegBase, leftLegBase, [0, -0.55, 0]); 

            // KAKI (Bentuk baru)
            mat4.clone(tempMatrix, leftLegBase);
            mat4.translate(tempMatrix, tempMatrix, [0, -0.05, 0.05]); 
            mat4.rotateX(tempMatrix, tempMatrix, -0.10); 
            mat4.scale(tempMatrix, tempMatrix, [0.6, 0.2, 0.7]); 
            mat3.normalFromMat4(normalMatrix, tempMatrix);
            drawObject(gl, programInfo, footBuffers, tempMatrix, normalMatrix, specularColor, shininess);

            let footMatrix = mat4.clone(mat4.create(), tempMatrix); 

            // Pelindung engkel (Sendi Kuning) 
            mat4.clone(tempMatrix2, footMatrix);
            mat4.translate(tempMatrix2, tempMatrix2, [0.5, 0.2, 0.02]); 
            mat4.scale(tempMatrix2, tempMatrix2, [2.5, 4.5, 2.5]);
            mat3.normalFromMat4(normalMatrix, tempMatrix2);
            drawObject(gl, programInfo, ankleGuardBuffers, tempMatrix2, normalMatrix, noSpecular, lowShininess);
            
            // Cakar (Bentuk baru) 
            let clawBaseMatrix = mat4.create();
            mat4.clone(clawBaseMatrix, leftLegBase);
            mat4.translate(clawBaseMatrix, clawBaseMatrix, [0, -0.05, 0.05]); 
            mat4.rotateX(clawBaseMatrix, clawBaseMatrix, -0.10); 

            for (let i = 0; i < 3; i++) {
                mat4.clone(tempMatrix2, clawBaseMatrix); 
                let xOffset = (i - 1.0) * 0.10; 
                mat4.translate(tempMatrix2, tempMatrix2, [xOffset, 0.0, 0.35]); 
                mat4.rotateX(tempMatrix2, tempMatrix2, -Math.PI / -2.0);
                mat4.scale(tempMatrix2, tempMatrix2, [1.5, 2.5, 1.5]); 
                mat3.normalFromMat4(normalMatrix, tempMatrix2);
                drawObject(gl, programInfo, clawBuffers, tempMatrix2, normalMatrix, noSpecular, lowShininess);
            }

            // KAKI KANAN (Berdiri) 
            let rightLegBase = mat4.clone(mat4.create(), globalModelMatrix);
            mat4.translate(rightLegBase, rightLegBase, [0.43, -0.85, 0.0]); 
            mat4.rotateX(rightLegBase, rightLegBase, -0.1); 
            mat4.rotateX(rightLegBase, rightLegBase, rightThighRot); // ANIMASI PAHA
            mat4.rotateZ(rightLegBase, rightLegBase, 0); 

            // Paha
            mat4.translate(rightLegBase, rightLegBase, [0, -0.28, 0]);
            mat4.clone(tempMatrix, rightLegBase);
            mat4.scale(tempMatrix, tempMatrix, [1.2, 1.7, 1.2]);
            mat3.normalFromMat4(normalMatrix, tempMatrix);
            drawObject(gl, programInfo, thighBuffers, tempMatrix, normalMatrix, specularColor, shininess);

            // Perban paha
            for (let i = 0; i < 4; i++) {
                mat4.clone(tempMatrix2, rightLegBase);
                mat4.translate(tempMatrix2, tempMatrix2, [0, 0.2 - (i * 0.12), 0]);
                mat4.rotateX(tempMatrix2, tempMatrix2, Math.PI / 2);
                mat3.normalFromMat4(normalMatrix, tempMatrix2);
                drawObject(gl, programInfo, bandageBuffers, tempMatrix2, normalMatrix, noSpecular, lowShininess);
            }

            // Lutut
            mat4.translate(rightLegBase, rightLegBase, [0, -0.28, 0]);
            mat4.rotateX(rightLegBase, rightLegBase, rightKneeRot); // ANIMASI LUTUT
            mat4.clone(tempMatrix, rightLegBase);
            mat3.normalFromMat4(normalMatrix, tempMatrix);
            drawObject(gl, programInfo, kneeBuffers, tempMatrix, normalMatrix, specularColor, shininess);

            // Betis
            mat4.rotateX(rightLegBase, rightLegBase, -0.0);
            mat4.translate(rightLegBase, rightLegBase, [0, -0.35, 0]);
            
            scaledCalfBase = mat4.create();
            mat4.clone(scaledCalfBase, rightLegBase); 
            mat4.scale(scaledCalfBase, scaledCalfBase, [1.50, 1.70, 1.5]); 

            // Perban betis 
            for (let i = 0; i < 9; i++) { 
                let curveAmount = 0.0; 
                let xOffset = Math.sin((i / 7.0) * Math.PI) * curveAmount; 

                mat4.clone(tempMatrix2, scaledCalfBase); 
                mat4.translate(tempMatrix2, tempMatrix2, [xOffset, 0.3 - (i * 0.08), 0]); 
                mat3.normalFromMat4(normalMatrix, tempMatrix2);
                drawObject(gl, programInfo, calfSegmentBuffers, tempMatrix2, normalMatrix, noSpecular, lowShininess);
                
                mat4.clone(tempMatrix2, scaledCalfBase); 
                mat4.translate(tempMatrix2, tempMatrix2, [xOffset, 0.3 - (i * 0.08) + 0.00, 0]); 
                mat3.normalFromMat4(normalMatrix, tempMatrix2);
                drawObject(gl, programInfo, calfSegmentLineBuffers, tempMatrix2, normalMatrix, noSpecular, lowShininess);
            }

            // Engkel dan kaki
            mat4.translate(rightLegBase, rightLegBase, [0, -0.55, 0]); 

            // KAKI
            mat4.clone(tempMatrix, rightLegBase); 
            mat4.translate(tempMatrix, tempMatrix, [0, -0.05, 0.05]); 
            mat4.rotateX(tempMatrix, tempMatrix, -0.10); 
            mat4.scale(tempMatrix, tempMatrix, [0.6, 0.2, 0.7]); 
            mat3.normalFromMat4(normalMatrix, tempMatrix);
            drawObject(gl, programInfo, footBuffers, tempMatrix, normalMatrix, specularColor, shininess);

            footMatrix = mat4.clone(mat4.create(), tempMatrix); 

            // Pelindung engkel (Sendi Kuning) 
            mat4.clone(tempMatrix2, footMatrix);
            mat4.translate(tempMatrix2, tempMatrix2, [-0.5, 0.2, 0.02]); 
            mat4.scale(tempMatrix2, tempMatrix2, [2.5, 4.5, 2.5]);
            mat3.normalFromMat4(normalMatrix, tempMatrix2);
            drawObject(gl, programInfo, ankleGuardBuffers, tempMatrix2, normalMatrix, noSpecular, lowShininess);
            
            // Cakar 
            clawBaseMatrix = mat4.create(); 
            mat4.clone(clawBaseMatrix, rightLegBase); 
            mat4.translate(clawBaseMatrix, clawBaseMatrix, [0, -0.05, 0.05]); 
            mat4.rotateX(clawBaseMatrix, clawBaseMatrix, -0.10); 

            for (let i = 0; i < 3; i++) {
                mat4.clone(tempMatrix2, clawBaseMatrix); 
                let xOffset = (i - 1.0) * 0.10; 
                mat4.translate(tempMatrix2, tempMatrix2, [xOffset, 0.0, 0.35]); 
                mat4.rotateX(tempMatrix2, tempMatrix2, -Math.PI / -2.0); 
                mat4.scale(tempMatrix2, tempMatrix2, [1.5, 2.5, 1.5]); 
                mat3.normalFromMat4(normalMatrix, tempMatrix2);
                drawObject(gl, programInfo, clawBuffers, tempMatrix2, normalMatrix, noSpecular, lowShininess);
            }

            requestAnimationFrame(render);
        }

        render();
    }

    window.onload = main;
    </script>
</body>
</html>